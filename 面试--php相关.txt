1.上传50M的文件，改哪些配置？
	1）.php.ini
	2).apache
	3).nginx
2.php 打开5个G的文件，怎么处理
	时间换空间
3.3万亿客户发信息，内存溢出怎么处理？
	一方面，我们要增加PHP可用内存大小，
	再一点就是：数据库操作完成后，要马上关闭连接；
	unset销毁变量并释放内存问题PHP的unset()函数用来清除、销毁变量，不用的变量，我们可以用unset()将它销毁
	
4.PHP实现对短信验证码发送限制（防止机刷验证码）
　　对用户获取短信验证码的手机号、ip、和浏览器（使用唯一标识）进行限制。
	本文介绍的方法是对用户每天只能通过同一浏览器或同一ip地址获取验证码10次或者同一手机号只能获取3次短信验证码，
	三种限制为“或”关系，一条超限就不发验证码。
	方法是通过在服务器端将用户的手机号、ip、ur_r记录并写入文件，再通过读取文件记录判断用户请求发送验证码的次数来做限制
	
5.常见的nosql
	Redis,Memcache,MongoDb
	
6.PHP 中 include 和 require 的区别详解，用什么代替include 和 require？
	1.include() 语句来说，在执行文件时每次都要进行读取和评估；而对于 require() 来说，文件只处理一次（实际上，文件内容替换 require() 语句）。
	2.如果执行多次的代码，则使用 require() 效率比较高
	3.incluce 在用到时加载，require 在一开始就加载
	4.include 的文件中出错了，主程序继续往下执行，require 的文件出错了，主程序也停了
	
	__autoload 可以代替


20.PHP实现类的自动加载的方法
	使用__autoload方法，当程序中new一个没有直接引入的类的时候，php执行引擎会自动调用该方法。
	因此，只要在该方法内编写类的路径引入逻辑，就能自动加载到该类并实现实例化。如果仍然查找不到，则会抛出一个异常。	
	
7.php传值和传引用的区别
	1.php传值：在函数范围内，改变变量值的大小，都不会影响到函数外边的变量值。
	2.PHP传引用：在函数范围内，对值的任何改变，在函数外部也有所体现，因为传引用传的是内存地址。
	3.传值会很耗时间，特别是对于大型的字符串和对象来说。传引用，函数内的任何操作等同于对传送变量的操作，传送大型变量时效率高
	
8.PHP的垃圾收集机制
	
9.双引号和单引号的区别
	单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断）
	
10.在PHP中error_reporting这个函数有什么作用？
	设置 PHP 的报错级别并返回当前级别。
11.oop是什么?

答:oop是面向对象编程,面向对象编程是一种计算机编程架构,OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。

OOP具有三大特点
	1、封装性：也称为信息隐藏，就是将一个类的使用和实现分开，只保留部分接口和方法与外部联系，或者说只公开了一些供开发人员使用的方法。
	于是开发人员只 需要关注这个类如何使用，而不用去关心其具体的实现过程，这样就能实现MVC分工合作，也能有效避免程序间相互依赖，实现代码模块间松藕合。
	2、继承性：就是子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。PHP只支持单继承，也就是说一个子类只能有一个父类。
	3、多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。于是多个子类中虽然都具有同一个方法，
	但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。
	
12.安全对一套程序来说至关重要，请说说在开发中应该注意哪些安全机制？
	①防远程提交；②防SQL注入，对特殊代码进行过滤；③防止注册机灌水，使用验证码；

13.__autoload()方法的工作原理是什么？
	答：使用这个魔术函数的基本条件是类文件的文件名要和类的名字保持一致。
	当程序执行到实例化某个类的时候，如果在实例化前没有引入这个类文件，那么就自动执行__autoload()函数。
	这个函数会根据实例化的类的名称来查找这个类文件的路径，当判断这个类文件路径下确实存在这个类文件后
	就执行include或者require来载入该类，然后程序继续执行，如果这个路径下不存在该文件时就提示错误。
	使用自动载入的魔术函数可以不必要写很多个include或者require函数。

14.i++和++i命令的区别有
	i++先做别的事，再自己加1
	++i先自己加1，再做别的事情
	++i比i++效率要高

15.负载均衡

16.PHP-FPM与Nginx的通信机制？

17.常见的排序算法
	冒泡排序
		在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
	选择排序
		在要排序的一组数中，选出最小的一个数与第一个位置的数交换。然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止
	插入排序
		在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。
	快速排序
		选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。
	
18.localhost与127.0.01的区别
	localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。
	127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。
	一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源
	
19.为什么会出现僵死进程（孤儿进程）？怎样查看僵死进程？如何解决僵死进程问题？
	答：僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
	查看：使用ps aux
	删除：ps aux | grep -e ‘^ [Zz]’ | awk ‘{print $2}’ | xargs kill -9

21.PHP类自动加载的意义
	1、相比于绝对路径引入类的文件路径，自动加载机制在当类库目录名或者文件名需要更改的时候，所有include了这个文件的php文件不需要随着修改，这避免了加大源代码目录结构重构的负担；
	2、相比于在php.ini中的include_path引入类的文件路径，自动加载的机制可以节省很多性能问题；
	
22.SESSION 与 COOKIE的区别是什么，请从协议，产生的原因与作用说明?
	SESSION存储在服务器端，COOKIE保存在客户端。Session比较安全，cookie用某些手段可以修改，不安全。Session依赖于cookie进行传递。
	禁用cookie后，session不能正常使用。Session的缺点：保存在服务器端，每次读取都从服务器进行读取，对服务器有资源消耗。Session保存在服务器端的文件或数据库中，
	默认保存在文件中，文件路径由php配置文件的session.save_path指定。Session文件是公有的。
	
23. 长连接、短连接的区别和使用
	长连接：client 方与 server 方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于 P2P 通信。
	短连接：Client 方与 server 每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。C/S 通信。
	长连接与短连接的使用时机：
		长连接：

		短连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个 TCP 连 接的建立都需要三次握手，每个 TCP 连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据 就可以了，不用再建立 TCP 连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误，频繁的 socket 创建也是对资源的浪 费。

		短连接：

		web 网站的 http 服务一般都用短连接。因为长连接对于服务器来说要耗费一定 的资源。像 web 网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个 连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。
		
24. HTTP 协议详解、应用
	http（超文本传输协议）是一个基于请求与响应模式的、无状态的、短连接、灵活、应用层的协议，常基于 TCP 的连接方式。

	HTTP 响应状态码

	状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：

	1xx：指示信息 -- 表示请求已接收，继续处理

	2xx：成功 -- 表示请求已被成功接收、理解、接受

	3xx：重定向 -- 要完成请求必须进行更进一步的操作

	4xx：客户端错误 -- 请求有语法错误或请求无法实现

	5xx：服务器端错误 -- 服务器未能实现合法的请求

	常见状态代码、状态描述、说明：

	200 OK // 客户端请求成功

	400 Bad Request // 客户端请求有语法错误，不能被服务器所理解

	401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden // 服务器收到请求，但是拒绝提供服务

	404 Not Found // 请求资源不存在，eg：输入了错误的 URL

	500 Internal Server Error // 服务器发生不可预期的错误

	503 Server Unavailable // 服务器超时 // 可能恢复正常

	304 Not Modifed // 自从上次请求后，请求的网页未修改过。

25. TCP 协议，三次握手、四次挥手
	TCP 协议 (Transmission Control Protocol) 是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接，四次挥手断开连接。

	位码即 tcp 标志位，有 6 种标示:

	SYN (synchronous 建立联机) 同步

	ACK (acknowledgement 确认)

	PSH (push 传送)

	FIN (finish 结束)

	RST (reset 重置)

	URG (urgent 紧急)
	
26. 常见的 web 攻击方式
	常见攻击
	1.XSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入的恶意 html 代码会被执行，从而达到恶意用户的特殊 目的。XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。但是随着前端技术的不断进步富客户端的应用越来越多，这方面的问题越来 越受关注。举个简单例子 ： 假如你现在是 sns 站点上一个用户，发布信息的功能存在漏洞可以执行 js 你在 此刻输入一个 恶意脚本，那么当前所有看到你新信息的人的浏览器都会执行这个脚本弹出提示框 （很爽吧 弹出广告 ：）），如果你做一些更为激进行为呢 后果难以想象。

	2.CSRF (Cross Site Request Forgery)，跨站点伪造请求。顾名思义就是 通过伪造连接请求在用户不知情的情况下，让用户以自己的身份来完成攻击者需要达到的一些目的。csrf 的攻击不同于 xss csrf 需要被攻击者的主动行为触发。这样听来似乎是有 “被钓鱼” 的嫌疑。

	多窗口浏览器这这方面似乎是有助纣为虐的嫌疑，因为打开的新窗口是具有当前所有 会话的，如果是单浏览器窗口类似 ie6 就不会存在这样的问题，因为每个窗口都是一个独立的进程。举个简单例子 ： 你正在玩白社会， 看到有人发了一个连接，你点击过去，然后这个连接里面伪造了一个送礼物的表单，这仅仅是一个简单的例子，问题可见一般。

	3.cookie 劫持。通过获取页面的权限，在页面中写一个简单的到恶意站点的请 求，并携带用户的 cookie 获取 cookie 后通过 cookie 就可以直以被盗用户的身份登录站点。这就是 cookie 劫持。举个简单例子： 某人写了一篇很有意思的日志，然后分享给大家，很多人都点击查看并且分享了该日志，一切似乎都很正常，然而写日志的人却另有用心，在日志中偷偷隐藏了一个 对站外的请求，那么所有看过这片日志的人都会在不知情的情况下把自己的 cookie 发送给了 某人，那么他可以通过任意一个人的 cookie 来登录这个人的账户。

	4.SQL 注入攻击
		在 SQL 注入攻击 中，用户通过操纵表单或 GET 查询字符串，将信息添加到数据库查询中。

	5.DNS 攻击
		拒绝服务攻击
		拒绝服务攻击即攻击者想办法让目标机器停止提供服务，是黑客常用的攻击手段之。
		攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，不接收新的请求；二是使用 IP 欺骗，迫使服务器把合法用户的连接复位，影响合法用户的连接

27. PHP 做好防盗链的基本思想 防盗链
	什么是盗链？
		盗链是指服务提供商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面 (如广告)，直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。受益者不提供资源或提供很少的资源，而真正的服务提供商却得不到任何的收益。

		网站盗链会大量消耗被盗链网站的带宽，而真正的点击率也许会很小，严重损害了被盗链网站的利益。 如何做防盗链？

		1.不定期更名文件或者目录

		2.限制引用页
			原理是，服务器获取用户提交信息的网站地址，然后和真正的服务端的地址相比较， 如果一致则表明是站内提交，或者为自己信任的站点提交，否则视为盗链。实现时可以使用 HTTP_REFERER1 和 htaccess 文件 (需要启用 mod_Rewrite)，结合正则表达式去匹配用户的每一个访问请求。

		3.文件伪装
			文件伪装是目前用得最多的一种反盗链技术，一般会结合服务器端动态脚本 (PHP/JSP/ASP)。实际上用户请求的文件地址，只是一个经过伪装的脚本文件，这个脚本文件会对用户的请求作认证，一般会检查 Session，Cookie 或 HTTP_REFERER 作为判断是否为盗链的依据。而真实的文件实际隐藏在用户不能够访问的地方，只有用户通过验证以后才会返回给用户

		4.加密认证
			这种反盗链方式，先从客户端获取用户信息，然后根据这个信息和用户请求的文件名 字一起加密成字符串 (Session ID) 作为身份验证。只有当认证成功以后，服务端才会把用户需要的文件传送给客户。一般我们会把加密的 Session ID 作为 URL 参数的一部分传递给服务器，由于这个 Session ID 和用户的信息挂钩，所以别人就算是盗取了链接，该 Session ID 也无法通过身份认证，从而达到反盗链的目的。这种方式对于分布式盗链非常有效。

		5.随机附加码
			每次，在页面里生成一个附加码，并存在数据库里，和对应的图片相关，访问图片时和此附加码对比，相同则输出图片，否则输出 404 图片

		6.加入水印	
		
28.php的运行原理、cgi对比fastcgi以及php-cgi和php-fpm之间的联系区别
	CGI：
		CGI的英文是（COMMON GATEWAY INTERFACE）公共网关接口，它的作用就是帮助服务器与语言通信，这里就是nginx和php进行通信，因为nginx和php的语言不通，因此需要一个沟通转换的过程，而CGI就是这个沟通的协议。
		nginx服务器在接受到浏览器传递过来的数据后，如果请求的是静态的页面或者图片等无需动态处理的则会直接根据请求的url找到其位置然后返回给浏览器，这里无需php参与，但是如果是一个动态的页面请求，这个时候nginx就必须与php通信，这个时候就会需要用到cgi协议，将请求数据转换成php能理解的信息，然后php根据这些信息返回的信息也要通过cgi协议转换成nginx可以理解的信息，最后nginx接到这些信息再返回给浏览器。
	
	fast-cgi：
		传统的cgi协议在每次连接请求时，会开启一个进程进行处理，处理完毕会关闭该进程，因此下次连接，又要再次开启一个进程进行处理，因此有多少个连接就有多少个cgi进程，这也就是为什么传统的cgi会显得缓慢的原因，因此过多的进程会消耗资源和内存。而fast-cgi则是一个进程可以处理多个请求，和上面的cgi协议完全不一样，cgi是一个进程只能处理一个请求，这样就会导致大量的cgi程序，因此会给服务器带来负担。

29.PHP消息队列实现及应用
	从本质上说消息对列就是一个队列结构的中间件，也就是说消息放入这个中间件之后就可以直接返回，并不需要系统立即处理，而另外会有一个程序读取这些数据，并按顺序进行逐次处理。
　　也就是说当你遇到一个并发特别大并且耗时特别长同时还不需要立即返回处理结果，使用消息队列可以解决这类问题。

应用场景
　　数据冗余：比如订单系统，后续需要严格的进行数据转换和记录，消息队列可以把这些数据持久化的存储在队列中，然后有订单，后续处理程序进行获取，后续处理完之后在把这条记录进行删除来保证每一条记录都能够处理完成。
　　系统解耦：使用消息系统之后，入队系统和出队系统是分开的，也就说只要一天崩溃了，不会影响另外一台系统正常运转。
　　流量削峰：例如秒杀和抢购，我们可以配合缓存来使用消息队列，能够有效的顶住瞬间访问量，防止服务器承受不住导致崩溃。
　　异步通信：消息本身使用入队之后可以直接返回。
　　扩展性：例如订单队列，不仅可以处理订单，还可以给其他业务使用。
　　排序保证：有些场景需要按照产品的顺序进行处理比如单进单出从而保证数据按照一定的顺序处理，使用消息队列是可以的。

30.PHP abstract与interface之间的区别
	0.抽象类需要继承，用extends，而接口需要实现，用implements；
	1.一个类可以实现多个接口，但只能继承一个抽象类
	2.接口中每个方法都只有声明而没有实现，其中的每个方法实现类必须要实现；而抽象类中只需要实现抽象方法，其它方法可以选择性的实现；
	3.接口中只能声明public的方法，不能声明private和protected的方法，不能对方法进行实现，也不能声明实例变量；但是抽象类中可以
	
	详解：https://blog.csdn.net/luyaran/article/details/54137702
	
31.php多进程同时写入一个文件

32.php-swoole 实现时时聊天

33.PHP 微服务架构，什么是微服务，优缺点

34.tp5和6，laravel 的区别详解


